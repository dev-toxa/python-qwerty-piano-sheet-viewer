<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Player & Sheet Music</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background-color: #f8fafc;
        }

        .canvas-container {
            padding: 30px 10px;
            background: white;
            min-width: 950px;
            position: relative;
        }

        #output-scroll {
            max-height: 70vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);
        }

        .playing-note {
            fill: #ef4444 !important;
            stroke: #ef4444 !important;
        }

        .control-btn {
            transition: all 0.2s;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>

<body class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-slate-800">MIDI 재생 악보 렌더러</h1>
            <p class="text-slate-500 mt-2">Grand Piano 사운드와 함께 MIDI 악보를 감상하세요.</p>
        </header>

        <!-- Player Controls -->
        <div class="bg-white p-6 rounded-2xl shadow-sm mb-6 border border-slate-200">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="flex items-center gap-2">
                    <button id="play-btn" disabled
                        class="control-btn bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-full font-bold flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16">
                            <path
                                d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z" />
                        </svg>
                        재생
                    </button>
                    <button id="pause-btn" disabled
                        class="control-btn bg-slate-200 hover:bg-slate-300 text-slate-700 px-6 py-2 rounded-full font-bold flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16">
                            <path
                                d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z" />
                        </svg>
                        일시정지
                    </button>
                    <button id="stop-btn" disabled
                        class="control-btn bg-slate-200 hover:bg-slate-300 text-slate-700 px-6 py-2 rounded-full font-bold flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16">
                            <path
                                d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z" />
                        </svg>
                        정지
                    </button>
                </div>
                <div id="progress-container"
                    class="flex-1 w-full max-w-md bg-slate-100 h-2 rounded-full overflow-hidden relative">
                    <div id="progress-bar" class="bg-blue-500 h-full w-0 transition-all duration-100"></div>
                </div>
            </div>

            <div class="mt-6 flex items-center justify-center w-full">
                <label
                    class="flex flex-col items-center justify-center w-full h-24 border-2 border-slate-300 border-dashed rounded-xl cursor-pointer bg-slate-50 hover:bg-slate-100 transition-all">
                    <div class="flex flex-col items-center justify-center pt-2">
                        <p class="text-sm text-slate-500 font-semibold">새로운 MIDI 파일 업로드</p>
                    </div>
                    <input id="midi-input" type="file" class="hidden" accept=".mid,.midi" />
                </label>
            </div>
            <div id="status" class="mt-2 text-center text-xs font-medium text-blue-600"></div>
        </div>

        <!-- Sheet Music Canvas -->
        <div id="output-scroll" class="hidden bg-white border border-slate-200 overflow-x-auto">
            <div id="vexflow-canvas" class="canvas-container"></div>
        </div>
    </div>

    <script>
        const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental, Annotation } = Vex.Flow;

        const keyMap = {
            "1": "C1", "!": "C#1", "2": "D1", "@": "D#1", "3": "E1", "4": "F1", "$": "F#1", "5": "G1",
            "%": "G#1", "6": "A1", "^": "A#1", "7": "B1", "8": "C2", "*": "C#2", "9": "D2", "(": "D#2",
            "0": "E2", "q": "F2", "Q": "F#2", "w": "G2", "W": "G#2", "e": "A2", "E": "A#2", "r": "B2",
            "t": "C3", "T": "C#3", "y": "D3", "Y": "D#3", "u": "E3", "i": "F3", "I": "F#3", "o": "G3",
            "O": "G#3", "p": "A3", "P": "A#3", "a": "B3", "s": "C4", "S": "C#4", "d": "D4", "D": "D#4",
            "f": "E4", "g": "F4", "G": "F#4", "h": "G4", "H": "G#4", "j": "A4", "J": "A#4", "k": "B4",
            "l": "C5", "L": "C#5", "z": "D5", "Z": "D#5", "x": "E5", "c": "F5", "C": "F5",
            "v": "G5", "V": "G#5", "b": "A5", "B": "A#5", "n": "B5", "m": "C6", "M": "C#6"
        };

        const pitchNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        let currentMidi = null;
        let sampler = null;
        let isPlaying = false;
        let vexNotesMap = [];

        // Initialize Sampler with Grand Piano sound
        async function initAudio() {
            if (sampler) return;

            return new Promise((resolve) => {
                sampler = new Tone.Sampler({
                    urls: {
                        "A0": "A0.mp3",
                        "C1": "C1.mp3",
                        "D#1": "Ds1.mp3",
                        "F#1": "Fs1.mp3",
                        "A1": "A1.mp3",
                        "C2": "C2.mp3",
                        "D#2": "Ds2.mp3",
                        "F#2": "Fs2.mp3",
                        "A2": "A2.mp3",
                        "C3": "C3.mp3",
                        "D#3": "Ds3.mp3",
                        "F#3": "Fs3.mp3",
                        "A3": "A3.mp3",
                        "C4": "C4.mp3",
                        "D#4": "Ds4.mp3",
                        "F#4": "Fs4.mp3",
                        "A4": "A4.mp3",
                        "C5": "C5.mp3",
                        "D#5": "Ds5.mp3",
                        "F#5": "Fs5.mp3",
                        "A5": "A5.mp3",
                        "C6": "C6.mp3"
                    },
                    release: 1,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                    onload: () => {
                        console.log("Grand Piano Sampler Loaded");
                        resolve();
                    }
                }).toDestination();
            });
        }

        function toVexKey(pitch) {
            const name = pitchNames[pitch % 12].replace('#', '');
            const octave = Math.floor(pitch / 12) - 1;
            return `${name}/${octave}`;
        }

        function toNoteName(pitch) {
            const name = pitchNames[pitch % 12];
            const octave = Math.floor(pitch / 12) - 1;
            return name + octave;
        }

        function findKeyMapChar(noteName) {
            for (let k in keyMap) {
                if (keyMap[k] === noteName) return k;
            }
            return null;
        }

        function ticksToDuration(durationTicks, ppq) {
            const ratio = durationTicks / ppq;
            if (ratio >= 3.8) return "w";
            if (ratio >= 1.8) return "h";
            if (ratio >= 0.8) return "q";
            if (ratio >= 0.4) return "8";
            if (ratio >= 0.2) return "16";
            return "32";
        }

        function durationToBeats(dur) {
            const map = { "w": 4, "h": 2, "q": 1, "8": 0.5, "16": 0.25, "32": 0.125 };
            return map[dur] || 1;
        }

        document.getElementById('midi-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const status = document.getElementById('status');
            status.innerText = "파일 로딩 및 악보 생성 중...";

            try {
                const arrayBuffer = await file.arrayBuffer();
                currentMidi = new Midi(arrayBuffer);
                renderSheetMusic(currentMidi);

                document.getElementById('play-btn').disabled = false;
                document.getElementById('stop-btn').disabled = false;
                document.getElementById('pause-btn').disabled = false;
                status.innerText = `로딩 완료: ${file.name}`;
                document.getElementById('output-scroll').classList.remove('hidden');
            } catch (err) {
                console.error(err);
                status.innerText = "오류 발생: " + err.message;
            }
        });

        // Player Logic
        document.getElementById('play-btn').addEventListener('click', async () => {
            const status = document.getElementById('status');
            if (!sampler) {
                status.innerText = "피아노 샘플을 로딩 중입니다... 잠시만 기다려주세요.";
                await initAudio();
                status.innerText = "피아노 사운드 로딩 완료!";
            }

            await Tone.start();
            if (isPlaying) return;

            isPlaying = true;
            Tone.Transport.cancel();

            const track = currentMidi.tracks.reduce((prev, curr) => prev.notes.length > curr.notes.length ? prev : curr);

            track.notes.forEach(note => {
                Tone.Transport.schedule(time => {
                    sampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                    Tone.Draw.schedule(() => {
                        highlightNote(note.ticks);
                    }, time);
                }, note.time);
            });

            Tone.Transport.start();
            updateProgressBar();
        });

        document.getElementById('pause-btn').addEventListener('click', () => {
            Tone.Transport.pause();
            isPlaying = false;
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            Tone.Transport.stop();
            Tone.Transport.cancel();
            isPlaying = false;
            document.getElementById('progress-bar').style.width = '0%';
            clearHighlights();
        });

        function updateProgressBar() {
            if (!isPlaying) return;
            const progress = (Tone.Transport.seconds / currentMidi.duration) * 100;
            document.getElementById('progress-bar').style.width = Math.min(progress, 100) + '%';
            if (progress < 100) requestAnimationFrame(updateProgressBar);
        }

        function highlightNote(ticks) {
            clearHighlights();
            const group = vexNotesMap.find(m => Math.abs(m.ticks - ticks) < (currentMidi.header.ppq / 8));
            if (group && group.element) {
                group.element.classList.add('playing-note');
                group.element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.playing-note').forEach(el => el.classList.remove('playing-note'));
        }

        function renderSheetMusic(midi) {
            const canvasContainer = document.getElementById('vexflow-canvas');
            canvasContainer.innerHTML = '';
            vexNotesMap = [];

            const track = midi.tracks.reduce((prev, current) =>
                (prev.notes.length > current.notes.length) ? prev : current
            );

            const ppq = midi.header.ppq;
            const sortedNotes = track.notes.sort((a, b) => a.ticks - b.ticks);

            const noteGroups = [];
            let currentGroup = [];
            const threshold = ppq / 16;

            sortedNotes.forEach(note => {
                if (currentGroup.length === 0) {
                    currentGroup.push(note);
                } else {
                    if (Math.abs(note.ticks - currentGroup[0].ticks) < threshold) {
                        currentGroup.push(note);
                    } else {
                        noteGroups.push([...currentGroup]);
                        currentGroup = [note];
                    }
                }
            });
            if (currentGroup.length > 0) noteGroups.push(currentGroup);

            const measures = [];
            let currentMeasure = [];
            let currentMeasureTicks = 0;
            const ticksPerMeasure = ppq * 4;

            noteGroups.forEach(group => {
                const durCode = ticksToDuration(group[0].durationTicks, ppq);
                const durVal = durationToBeats(durCode) * ppq;

                if (currentMeasureTicks + durVal > ticksPerMeasure && currentMeasure.length > 0) {
                    measures.push(currentMeasure);
                    currentMeasure = [];
                    currentMeasureTicks = 0;
                }
                currentMeasure.push({ group, durCode, ticks: group[0].ticks });
                currentMeasureTicks += durVal;
            });
            if (currentMeasure.length > 0) measures.push(currentMeasure);

            const fullWidth = 1000;
            const measuresPerRow = 2;
            const renderer = new Renderer(canvasContainer, Renderer.Backends.SVG);
            const context = renderer.getContext();
            const rowCount = Math.ceil(measures.length / measuresPerRow);
            renderer.resize(fullWidth, rowCount * 160 + 100);

            measures.forEach((measure, idx) => {
                const col = idx % measuresPerRow;
                const row = Math.floor(idx / measuresPerRow);
                const staveWidth = (fullWidth - 40) / measuresPerRow;
                const x = 20 + (col * staveWidth);
                const y = row * 150 + 50;

                const stave = new Stave(x, y, staveWidth);
                if (col === 0) {
                    stave.addClef("treble");
                    if (row === 0) stave.addTimeSignature("4/4");
                }
                stave.setContext(context).draw();

                const vexNotes = measure.map(m => {
                    const keys = m.group.map(n => toVexKey(n.midi));
                    const staveNote = new StaveNote({
                        keys: keys,
                        duration: m.durCode,
                        clef: "treble"
                    });

                    m.group.forEach((n, i) => {
                        if (pitchNames[n.midi % 12].includes('#')) {
                            staveNote.addModifier(new Accidental("#"), i);
                        }
                    });

                    let label = m.group.map(n => findKeyMapChar(toNoteName(n.midi)) || "?").join("");
                    if (m.group.length > 1) label = "[" + label + "]";

                    staveNote.addModifier(new Annotation(label)
                        .setVerticalJustification(Annotation.VerticalJustify.TOP)
                        .setFont("Arial", 10, "bold")
                    );

                    return staveNote;
                });

                if (vexNotes.length > 0) {
                    const totalBeats = measure.reduce((acc, m) => acc + durationToBeats(m.durCode), 0);
                    const voice = new Voice({ num_beats: totalBeats, beat_value: 4 });
                    voice.setStrict(false);
                    voice.addTickables(vexNotes);
                    new Formatter().joinVoices([voice]).format([voice], staveWidth - (col === 0 ? 60 : 20));
                    voice.draw(context, stave);

                    vexNotes.forEach((vn, i) => {
                        const elem = vn.getAttribute("el");
                        if (elem) {
                            vexNotesMap.push({
                                ticks: measure[i].ticks,
                                element: elem
                            });
                        }
                    });
                }
            });
        }
    </script>
</body>

</html>