<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Shorts Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background-color: #0f172a;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        .shorts-container {
            width: 100vw;
            max-width: 400px;
            height: 92vh;
            background: #ffffff;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            overflow: hidden;
        }

        #output-scroll {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: white;
            scroll-behavior: smooth;
            position: relative;
            padding: 20px 0;
        }

        .canvas-container {
            width: 100%;
            position: relative;
            min-height: 100%;
        }

        /* 재생 커서 스타일: 시인성이 매우 높은 형광색 적용 */
        #playhead {
            position: absolute;
            width: 4px;
            background-color: #ff3c00; /* 형광 주황 */
            pointer-events: none;
            display: none;
            z-index: 10000 !important; 
            border-radius: 2px;
            box-shadow: 0 0 12px #ff3c00, 0 0 4px white;
            opacity: 0.9;
            transition: left 0.1s linear, top 0.2s ease-in-out;
        }

        .controls-top {
            padding: 16px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            z-index: 1001;
        }

        /* 재생 중인 노트 및 계명 강조 스타일 */
        .playing-note path, 
        .playing-note ellipse {
            fill: #ef4444 !important; /* 강렬한 빨간색 음표 */
            stroke: #ef4444 !important;
            filter: drop-shadow(0 0 4px rgba(239, 68, 68, 0.8));
        }

        /* 재생 중인 텍스트(계명) 강조 */
        .playing-note .vf-annotation text {
            fill: #f59e0b !important; /* 선명한 노란색 */
            font-weight: 900 !important;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
        }

        /* 마디 컨테이너 간격 */
        .measure-container {
            margin-bottom: 100px; 
            display: flex;
            justify-content: center;
        }

        .vf-annotation {
            font-weight: 800 !important;
            fill: #1e293b !important;
        }
    </style>
</head>

<body>
    <div class="shorts-container">
        <div class="controls-top">
            <div class="flex items-center justify-between gap-4">
                <div class="truncate flex-1">
                    <h2 class="text-slate-800 font-bold text-sm truncate" id="title-display">파일을 선택하세요</h2>
                    <p id="status" class="text-[10px] text-slate-500 font-medium uppercase tracking-tighter">Waiting for MIDI...</p>
                </div>
                <div class="flex gap-2">
                    <button id="play-btn" disabled class="w-10 h-10 flex items-center justify-center bg-blue-600 text-white rounded-full hover:scale-105 active:scale-95 disabled:opacity-20 transition-transform">
                        <svg viewBox="0 0 16 16" class="w-5 h-5" fill="currentColor"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z" /></svg>
                    </button>
                    <button id="stop-btn" disabled class="w-10 h-10 flex items-center justify-center bg-slate-200 text-slate-700 rounded-full hover:scale-105 active:scale-95 disabled:opacity-20 transition-transform">
                        <svg viewBox="0 0 16 16" class="w-5 h-5" fill="currentColor"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z" /></svg>
                    </button>
                </div>
            </div>
            <div class="mt-4 bg-slate-200 h-1 rounded-full overflow-hidden">
                <div id="progress-bar" class="bg-blue-500 h-full w-0"></div>
            </div>
            <input type="file" id="midi-input" class="hidden" accept=".mid,.midi" />
            <button onclick="document.getElementById('midi-input').click()" class="mt-3 w-full py-1 text-[10px] text-slate-400 border border-slate-200 rounded-md hover:bg-slate-50 transition-colors uppercase font-bold tracking-widest">Upload MIDI</button>
        </div>

        <div id="output-scroll">
            <div id="vexflow-canvas" class="canvas-container">
                <div id="playhead"></div>
            </div>
        </div>
    </div>

    <script>
        const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental, Annotation } = Vex.Flow;

        const pitchNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const keyMap = { "1": "C1", "!": "C#1", "2": "D1", "@": "D#1", "3": "E1", "4": "F1", "$": "F#1", "5": "G1", "%": "G#1", "6": "A1", "^": "A#1", "7": "B1", "8": "C2", "*": "C#2", "9": "D2", "(": "D#2", "0": "E2", "q": "F2", "Q": "F#2", "w": "G2", "W": "G#2", "e": "A2", "E": "A#2", "r": "B2", "t": "C3", "T": "C#3", "y": "D3", "Y": "D#3", "u": "E3", "i": "F3", "I": "F#3", "o": "G3", "O": "G#3", "p": "A3", "P": "A#3", "a": "B3", "s": "C4", "S": "C#4", "d": "D4", "D": "D#4", "f": "E4", "g": "F4", "G": "F#4", "h": "G4", "H": "G#4", "j": "A4", "J": "A#4", "k": "B4", "l": "C5", "L": "C#5", "z": "D5", "Z": "D#5", "x": "E5", "c": "F5", "C": "F5", "v": "G5", "V": "G#5", "b": "A5", "B": "A#5", "n": "B5", "m": "C6", "M": "C#6" };

        let currentMidi = null;
        let sampler = null;
        let isPlaying = false;
        let vexNotesMap = []; 

        async function initAudio() {
            if (sampler) return;
            sampler = new Tone.Sampler({
                urls: { "A0": "A0.mp3", "C1": "C1.mp3", "C4": "C4.mp3", "A4": "A4.mp3" },
                baseUrl: "https://tonejs.github.io/audio/salamander/"
            }).toDestination();
            await Tone.loaded();
        }

        document.getElementById('midi-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('status').innerText = "Rendering...";
            document.getElementById('title-display').innerText = file.name;

            const arrayBuffer = await file.arrayBuffer();
            currentMidi = new Midi(arrayBuffer);
            renderSheet(currentMidi);

            document.getElementById('play-btn').disabled = false;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('status').innerText = "Ready to Play";
        });

        document.getElementById('play-btn').addEventListener('click', async () => {
            if (!currentMidi) return;
            await initAudio();
            await Tone.start();

            if (isPlaying) {
                Tone.Transport.pause();
                isPlaying = false;
                document.getElementById('status').innerText = "Paused";
                return;
            }

            isPlaying = true;
            document.getElementById('status').innerText = "Playing";
            document.getElementById('playhead').style.display = 'block';
            
            const track = currentMidi.tracks.reduce((p, c) => p.notes.length > c.notes.length ? p : c);
            Tone.Transport.cancel();
            
            track.notes.forEach(note => {
                Tone.Transport.schedule(time => {
                    sampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                    Tone.Draw.schedule(() => {
                        updateNoteUI(note.ticks);
                    }, time);
                }, note.time);
            });

            Tone.Transport.start();
            loopUI();
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            Tone.Transport.stop();
            Tone.Transport.cancel();
            isPlaying = false;
            document.getElementById('playhead').style.display = 'none';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('status').innerText = "Stopped";
            clearHighlights();
        });

        function loopUI() {
            if (!isPlaying) return;
            const progress = (Tone.Transport.seconds / currentMidi.duration) * 100;
            document.getElementById('progress-bar').style.width = progress + '%';
            requestAnimationFrame(loopUI);
        }

        function updateNoteUI(ticks) {
            clearHighlights();
            const threshold = currentMidi.header.ppq / 8;
            const match = vexNotesMap.find(m => Math.abs(m.ticks - ticks) < threshold);
            
            if (match && match.element) {
                match.element.classList.add('playing-note');
                
                const playhead = document.getElementById('playhead');
                const bbox = match.element.getBBox();
                const svg = match.element.ownerSVGElement;
                const measureDiv = svg.parentElement;
                
                const relativeTop = measureDiv.offsetTop;
                const relativeLeft = bbox.x + 10; 

                playhead.style.left = `${relativeLeft}px`;
                playhead.style.top = `${relativeTop + 40}px`; 
                playhead.style.height = `70px`; 
                
                const scrollContainer = document.getElementById('output-scroll');
                const scrollTarget = relativeTop - (scrollContainer.offsetHeight / 2) + 90;
                scrollContainer.scrollTo({ top: scrollTarget, behavior: 'smooth' });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.playing-note').forEach(el => el.classList.remove('playing-note'));
        }

        function renderSheet(midi) {
            const container = document.getElementById('vexflow-canvas');
            const playhead = document.getElementById('playhead');
            container.innerHTML = '';
            container.appendChild(playhead);
            
            vexNotesMap = [];
            const track = midi.tracks.reduce((p, c) => p.notes.length > c.notes.length ? p : c);
            const ppq = midi.header.ppq;
            const sortedNotes = track.notes.sort((a, b) => a.ticks - b.ticks);

            let measures = [];
            let temp = [];
            let currentTicks = 0;
            const ticksPerMeasure = ppq * 4;

            sortedNotes.forEach(n => {
                while (n.ticks >= currentTicks + ticksPerMeasure) {
                    measures.push(temp);
                    temp = [];
                    currentTicks += ticksPerMeasure;
                }
                temp.push(n);
            });
            if (temp.length) measures.push(temp);

            const canvasWidth = 360;

            measures.forEach((mNotes, idx) => {
                const div = document.createElement('div');
                div.className = "measure-container relative";
                container.appendChild(div);

                const renderer = new Renderer(div, Renderer.Backends.SVG);
                const context = renderer.getContext();
                renderer.resize(canvasWidth, 200); 

                const stave = new Stave(10, 50, canvasWidth - 20); 
                stave.addClef("treble").setContext(context).draw();

                const timeGroups = [];
                mNotes.forEach(n => {
                    let group = timeGroups.find(g => Math.abs(g.ticks - n.ticks) < 10);
                    if (group) group.notes.push(n);
                    else timeGroups.push({ ticks: n.ticks, notes: [n] });
                });

                const vexNotes = timeGroups.map(tg => {
                    const sn = new StaveNote({
                        keys: tg.notes.map(n => {
                            const octave = Math.floor(n.midi / 12) - 1;
                            return pitchNames[n.midi % 12].replace('#','') + "/" + octave;
                        }),
                        duration: "q"
                    });

                    tg.notes.forEach((n, i) => {
                        if (pitchNames[n.midi % 12].includes('#')) sn.addModifier(new Accidental("#"), i);
                    });

                    // 동시노트 계명 처리: 여러 개일 경우 [, ] 로 묶음
                    let labelsText = tg.notes.map(n => {
                        const fullNoteName = pitchNames[n.midi % 12] + (Math.floor(n.midi/12)-1);
                        return Object.keys(keyMap).find(k => keyMap[k] === fullNoteName) || "";
                    }).join("");
                    
                    if (labelsText) {
                        // 화음(노트가 2개 이상)이면 대괄호 추가
                        const finalLabel = tg.notes.length > 1 ? `[${labelsText}]` : labelsText;
                        sn.addModifier(new Annotation(finalLabel).setVerticalJustification(Annotation.VerticalJustify.TOP).setFont("Arial", 13, "bold"));
                    }

                    return sn;
                });

                if (vexNotes.length) {
                    const voice = new Voice({ num_beats: 4, beat_value: 4 }).setStrict(false);
                    voice.addTickables(vexNotes);
                    new Formatter().joinVoices([voice]).format([voice], canvasWidth - 60);
                    voice.draw(context, stave);

                    vexNotes.forEach((vn, i) => {
                        const el = vn.getAttribute("el");
                        if (el) vexNotesMap.push({ ticks: timeGroups[i].ticks, element: el });
                    });
                }
            });
        }
    </script>
</body>
</html>